$date
	Thu Aug 22 19:16:50 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module ripple_adder_tb $end
$var wire 1 ! res_carry $end
$var wire 4 " res_sum [3:0] $end
$var reg 4 # in1 [3:0] $end
$var reg 4 $ in2 [3:0] $end
$var reg 1 % in3 $end
$scope module ra $end
$var wire 4 & A [3:0] $end
$var wire 4 ' B [3:0] $end
$var wire 1 ( CIN $end
$var wire 1 ! COUT $end
$var wire 4 ) SUM [3:0] $end
$var wire 1 * c1out $end
$var wire 1 + c2out $end
$var wire 1 , c3out $end
$scope module fa0 $end
$var wire 1 - a $end
$var wire 1 . b $end
$var wire 1 ( cin $end
$var wire 1 * cout $end
$var wire 1 / in_and $end
$var wire 1 0 in_xor $end
$var wire 1 1 sum $end
$var wire 1 2 x1_and $end
$upscope $end
$scope module fa1 $end
$var wire 1 3 a $end
$var wire 1 4 b $end
$var wire 1 * cin $end
$var wire 1 + cout $end
$var wire 1 5 in_and $end
$var wire 1 6 in_xor $end
$var wire 1 7 sum $end
$var wire 1 8 x1_and $end
$upscope $end
$scope module fa2 $end
$var wire 1 9 a $end
$var wire 1 : b $end
$var wire 1 + cin $end
$var wire 1 , cout $end
$var wire 1 ; in_and $end
$var wire 1 < in_xor $end
$var wire 1 = sum $end
$var wire 1 > x1_and $end
$upscope $end
$scope module fa3 $end
$var wire 1 ? a $end
$var wire 1 @ b $end
$var wire 1 , cin $end
$var wire 1 ! cout $end
$var wire 1 A in_and $end
$var wire 1 B in_xor $end
$var wire 1 C sum $end
$var wire 1 D x1_and $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
09
08
17
16
05
14
03
02
11
10
0/
0.
1-
0,
0+
0*
b11 )
0(
b10 '
b1 &
0%
b10 $
b1 #
b11 "
0!
$end
#10000
1=
1+
1*
06
15
01
b110 "
b110 )
12
13
1%
1(
b11 #
b11 &
#20000
0C
0,
0+
1=
0>
0*
16
05
1<
11
b111 "
b111 )
02
03
19
0%
0(
b101 #
b101 &
#30000
1!
1D
0=
1,
0C
1*
06
0<
1;
1B
01
b10 "
b10 )
12
04
1:
1?
1%
1(
b100 $
b100 '
b1101 #
b1101 &
#50000
